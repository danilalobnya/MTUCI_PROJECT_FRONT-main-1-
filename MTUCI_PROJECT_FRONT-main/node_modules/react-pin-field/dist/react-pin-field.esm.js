import React, { useCallback, forwardRef, useRef, useImperativeHandle } from 'react';
import { useBireducer } from 'react-use-bireducer';

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

/**
 * KeyboardEvent.key polyfill.
 *
 * @see https://github.com/soywod/keyboardevent-key-polyfill/blob/master/index.js
 */
var keyMap = {
  3: "Cancel",
  6: "Help",
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  28: "Convert",
  29: "NonConvert",
  30: "Accept",
  31: "ModeChange",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  41: "Select",
  42: "Print",
  43: "Execute",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  48: ["0", ")"],
  49: ["1", "!"],
  50: ["2", "@"],
  51: ["3", "#"],
  52: ["4", "$"],
  53: ["5", "%"],
  54: ["6", "^"],
  55: ["7", "&"],
  56: ["8", "*"],
  57: ["9", "("],
  91: "OS",
  93: "ContextMenu",
  106: "*",
  107: "+",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  181: "VolumeMute",
  182: "VolumeDown",
  183: "VolumeUp",
  186: [";", ":"],
  187: ["=", "+"],
  188: [",", "<"],
  189: ["-", "_"],
  190: [".", ">"],
  191: ["/", "?"],
  192: ["`", "~"],
  219: ["[", "{"],
  220: ["\\", "|"],
  221: ["]", "}"],
  222: ["'", '"'],
  224: "Meta",
  225: "AltGraph",
  246: "Attn",
  247: "CrSel",
  248: "ExSel",
  249: "EraseEof",
  250: "Play",
  251: "ZoomOut"
};
// Function keys (F1-24).
var i;
for (i = 1; i < 25; i += 1) {
  keyMap[111 + i] = "F" + i;
}
// Printable ASCII characters.
for (i = 65; i < 91; i += 1) {
  var letter = /*#__PURE__*/String.fromCharCode(i);
  keyMap[i] = [/*#__PURE__*/letter.toLowerCase(), /*#__PURE__*/letter.toUpperCase()];
}
// Numbers on numeric keyboard.
for (i = 96; i < 106; i += 1) {
  keyMap[i] = /*#__PURE__*/String.fromCharCode(i - 48);
}
/**
 * Find the key associated to a keyboard event.
 * Default to "Unidentified".
 */
function getKeyFromKeyboardEvent(evt) {
  if (evt.key && evt.key !== "Unidentified") {
    return evt.key;
  }
  var key = keyMap[evt.which || evt.keyCode] || "Unidentified";
  if (Array.isArray(key)) {
    return key[+(evt.shiftKey || 0)];
  }
  return key;
}
var keyboardEventPolyfill = {
  getKey: getKeyFromKeyboardEvent
};

function noop() {
  //
}
function range(start, length) {
  return Array.from({
    length: length
  }, function (_, i) {
    return i + start;
  });
}
function omit(keys, input) {
  var output = Object.create({});
  for (var key in input) {
    if (!keys.includes(key)) {
      var _Object$assign;
      Object.assign(output, (_Object$assign = {}, _Object$assign[key] = input[key], _Object$assign));
    }
  }
  return output;
}

var _excluded = ["refs"];
var NO_EFFECTS = [];
var PROP_KEYS = ["autoFocus", "length", "validate", "format", "formatAriaLabel", "debug"];
var HANDLER_KEYS = ["onResolveKey", "onRejectKey", "onChange", "onComplete"];
var IGNORED_META_KEYS = ["Alt", "Control", "Enter", "Meta", "Shift", "Tab"];
var defaultProps = {
  ref: {
    current: []
  },
  length: 5,
  validate: /^[a-zA-Z0-9]$/,
  format: function format(key) {
    return key;
  },
  formatAriaLabel: function formatAriaLabel(idx, codeLength) {
    return "pin code " + idx + " of " + codeLength;
  },
  onResolveKey: noop,
  onRejectKey: noop,
  onChange: noop,
  onComplete: noop,
  debug: false
};
function defaultState(props) {
  return {
    focusIdx: 0,
    codeLength: props.length,
    isKeyAllowed: isKeyAllowed(props.validate),
    fallback: null
  };
}
function getPrevFocusIdx(currFocusIdx) {
  return Math.max(0, currFocusIdx - 1);
}
function getNextFocusIdx(currFocusIdx, lastFocusIdx) {
  if (lastFocusIdx === 0) return 0;
  return Math.min(currFocusIdx + 1, lastFocusIdx - 1);
}
function isKeyAllowed(predicate) {
  return function (key) {
    if (!key) return false;
    if (key.length > 1) return false;
    if (typeof predicate === "string") return predicate.split("").includes(key);
    if (predicate instanceof Array) return predicate.includes(key);
    if (predicate instanceof RegExp) return predicate.test(key);
    return predicate(key);
  };
}
function pasteReducer(state, idx, val) {
  var areAllKeysAllowed = val.split("").slice(0, state.codeLength).every(state.isKeyAllowed);
  if (!areAllKeysAllowed) {
    return [state, [{
      type: "set-input-val",
      idx: state.focusIdx,
      val: ""
    }, {
      type: "reject-key",
      idx: idx,
      key: val
    }, {
      type: "handle-code-change"
    }]];
  }
  var pasteLen = Math.min(val.length, state.codeLength - state.focusIdx);
  var nextFocusIdx = getNextFocusIdx(pasteLen + state.focusIdx - 1, state.codeLength);
  var effects = range(0, pasteLen).flatMap(function (idx) {
    return [{
      type: "set-input-val",
      idx: idx + state.focusIdx,
      val: val[idx]
    }, {
      type: "resolve-key",
      idx: idx + state.focusIdx,
      key: val[idx]
    }];
  });
  if (state.focusIdx !== nextFocusIdx) {
    effects.push({
      type: "focus-input",
      idx: nextFocusIdx
    });
  }
  effects.push({
    type: "handle-code-change"
  });
  return [_extends({}, state, {
    focusIdx: nextFocusIdx
  }), effects];
}
var stateReducer = function stateReducer(state, action) {
  switch (action.type) {
    case "handle-key-down":
      {
        switch (action.key) {
          case "Unidentified":
          case "Process":
            {
              return [_extends({}, state, {
                fallback: {
                  idx: state.focusIdx,
                  val: action.val
                }
              }), NO_EFFECTS];
            }
          case "Dead":
            {
              return [state, [{
                type: "set-input-val",
                idx: state.focusIdx,
                val: ""
              }, {
                type: "reject-key",
                idx: state.focusIdx,
                key: action.key
              }, {
                type: "handle-code-change"
              }]];
            }
          case "ArrowLeft":
            {
              var prevFocusIdx = getPrevFocusIdx(state.focusIdx);
              return [_extends({}, state, {
                focusIdx: prevFocusIdx
              }), [{
                type: "focus-input",
                idx: prevFocusIdx
              }]];
            }
          case "ArrowRight":
            {
              var nextFocusIdx = getNextFocusIdx(state.focusIdx, state.codeLength);
              return [_extends({}, state, {
                focusIdx: nextFocusIdx
              }), [{
                type: "focus-input",
                idx: nextFocusIdx
              }]];
            }
          case "Delete":
          case "Backspace":
            {
              return [state, [{
                type: "handle-delete",
                idx: state.focusIdx
              }, {
                type: "handle-code-change"
              }]];
            }
          default:
            {
              if (!state.isKeyAllowed(action.key)) {
                return [state, [{
                  type: "reject-key",
                  idx: state.focusIdx,
                  key: action.key
                }]];
              }
              var _nextFocusIdx = getNextFocusIdx(state.focusIdx, state.codeLength);
              return [_extends({}, state, {
                focusIdx: _nextFocusIdx
              }), [{
                type: "set-input-val",
                idx: state.focusIdx,
                val: action.key
              }, {
                type: "resolve-key",
                idx: state.focusIdx,
                key: action.key
              }, {
                type: "focus-input",
                idx: _nextFocusIdx
              }, {
                type: "handle-code-change"
              }]];
            }
        }
      }
    case "handle-key-up":
      {
        if (!state.fallback) {
          return [state, NO_EFFECTS];
        }
        var nextState = _extends({}, state, {
          fallback: null
        });
        var effects = [];
        var _state$fallback = state.fallback,
          idx = _state$fallback.idx,
          prevVal = _state$fallback.val;
        var val = action.val;
        if (prevVal === "" && val === "") {
          effects.push({
            type: "handle-delete",
            idx: idx
          }, {
            type: "handle-code-change"
          });
        } else if (val !== "") {
          return pasteReducer(nextState, idx, val);
        }
        return [nextState, effects];
      }
    case "handle-paste":
      {
        return pasteReducer(state, action.idx, action.val);
      }
    case "focus-input":
      {
        return [_extends({}, state, {
          focusIdx: action.idx
        }), [{
          type: "focus-input",
          idx: action.idx
        }]];
      }
    default:
      {
        return [state, NO_EFFECTS];
      }
  }
};
function useEffectReducer(_ref) {
  var refs = _ref.refs,
    props = _objectWithoutPropertiesLoose(_ref, _excluded);
  return useCallback(function (effect) {
    switch (effect.type) {
      case "focus-input":
        {
          refs.current[effect.idx].focus();
          break;
        }
      case "set-input-val":
        {
          var val = props.format(effect.val);
          refs.current[effect.idx].value = val;
          break;
        }
      case "resolve-key":
        {
          refs.current[effect.idx].setCustomValidity("");
          props.onResolveKey(effect.key, refs.current[effect.idx]);
          break;
        }
      case "reject-key":
        {
          refs.current[effect.idx].setCustomValidity("Invalid key");
          props.onRejectKey(effect.key, refs.current[effect.idx]);
          break;
        }
      case "handle-delete":
        {
          var prevVal = refs.current[effect.idx].value;
          refs.current[effect.idx].setCustomValidity("");
          refs.current[effect.idx].value = "";
          if (!prevVal) {
            var prevIdx = getPrevFocusIdx(effect.idx);
            refs.current[prevIdx].focus();
            refs.current[prevIdx].setCustomValidity("");
            refs.current[prevIdx].value = "";
          }
          break;
        }
      case "handle-code-change":
        {
          var dir = (props.dir || document.documentElement.getAttribute("dir") || "ltr").toLowerCase();
          var codeArr = refs.current.map(function (r) {
            return r.value.trim();
          });
          var code = (dir === "rtl" ? codeArr.reverse() : codeArr).join("");
          props.onChange(code);
          code.length === props.length && props.onComplete(code);
          break;
        }
    }
  }, [props, refs]);
}
var PinField = /*#__PURE__*/forwardRef(function (customProps, fwdRef) {
  var props = _extends({}, defaultProps, customProps);
  var autoFocus = props.autoFocus,
    formatAriaLabel = props.formatAriaLabel,
    codeLength = props.length;
  var inputProps = omit([].concat(PROP_KEYS, HANDLER_KEYS), props);
  var refs = useRef([]);
  var effectReducer = useEffectReducer(_extends({
    refs: refs
  }, props));
  var dispatch = useBireducer(stateReducer, effectReducer, defaultState(props))[1];
  useImperativeHandle(fwdRef, function () {
    return refs.current;
  }, [refs]);
  function handleFocus(idx) {
    return function () {
      dispatch({
        type: "focus-input",
        idx: idx
      });
    };
  }
  function handleKeyDown(idx) {
    return function (evt) {
      var key = keyboardEventPolyfill.getKey(evt.nativeEvent);
      if (!IGNORED_META_KEYS.includes(key) && !evt.ctrlKey && !evt.altKey && !evt.metaKey && evt.nativeEvent.target instanceof HTMLInputElement) {
        evt.preventDefault();
        dispatch({
          type: "handle-key-down",
          idx: idx,
          key: key,
          val: evt.nativeEvent.target.value
        });
      }
    };
  }
  function handleKeyUp(idx) {
    return function (evt) {
      if (evt.nativeEvent.target instanceof HTMLInputElement) {
        dispatch({
          type: "handle-key-up",
          idx: idx,
          val: evt.nativeEvent.target.value
        });
      }
    };
  }
  function handlePaste(idx) {
    return function (evt) {
      evt.preventDefault();
      var val = evt.clipboardData.getData("Text");
      dispatch({
        type: "handle-paste",
        idx: idx,
        val: val
      });
    };
  }
  function setRefAtIndex(idx) {
    return function (ref) {
      if (ref) {
        refs.current[idx] = ref;
      }
    };
  }
  function hasAutoFocus(idx) {
    return Boolean(idx === 0 && autoFocus);
  }
  return React.createElement(React.Fragment, null, range(0, codeLength).map(function (idx) {
    return React.createElement("input", Object.assign({
      type: "text",
      autoCapitalize: "off",
      autoCorrect: "off",
      autoComplete: "off",
      inputMode: "text"
    }, inputProps, {
      "aria-disabled": inputProps.disabled ? "true" : undefined,
      "aria-label": formatAriaLabel(idx + 1, codeLength),
      "aria-readonly": inputProps.readOnly ? "true" : undefined,
      "aria-required": "true",
      key: idx,
      ref: setRefAtIndex(idx),
      autoFocus: hasAutoFocus(idx),
      onFocus: handleFocus(idx),
      onKeyDown: handleKeyDown(idx),
      onKeyUp: handleKeyUp(idx),
      onPaste: handlePaste(idx)
    }));
  }));
});

export default PinField;
export { HANDLER_KEYS, IGNORED_META_KEYS, NO_EFFECTS, PROP_KEYS, PinField, defaultProps, defaultState, getNextFocusIdx, getPrevFocusIdx, isKeyAllowed, pasteReducer, stateReducer, useEffectReducer };
//# sourceMappingURL=react-pin-field.esm.js.map
